import { Dispatcher } from "@colyseus/command";
import { MapSchema } from "@colyseus/schema";
import { Client, Room } from "colyseus";
import { MiniGame } from "../core/matter/mini-game";
import { IGameUser } from "../models/colyseus-models/game-user";
import Player from "../models/colyseus-models/player";
import { Pokemon } from "../models/colyseus-models/pokemon";
import { IGameHistorySimplePlayer, IPokemon, IPokemonEntity } from "../types";
import { EloRank } from "../types/Config";
import { GameMode } from "../types/enum/Game";
import { Item } from "../types/enum/Item";
import { Pkm, PkmProposition } from "../types/enum/Pokemon";
import GameState from "./states/game-state";
export default class GameRoom extends Room<GameState> {
    dispatcher: Dispatcher<this>;
    additionalUncommonPool: Array<Pkm>;
    additionalRarePool: Array<Pkm>;
    additionalEpicPool: Array<Pkm>;
    miniGame: MiniGame;
    constructor();
    onCreate(options: {
        users: Record<string, IGameUser>;
        preparationId: string;
        name: string;
        ownerName: string;
        noElo: boolean;
        gameMode: GameMode;
        minRank: EloRank | null;
        tournamentId: string | null;
        bracketId: string | null;
    }): Promise<void>;
    startGame(): void;
    onAuth(client: Client, options: any, request: any): Promise<import("firebase-admin/lib/auth/user-record").UserRecord | undefined>;
    onJoin(client: Client, options: any, auth: any): void;
    onLeave(client: Client, consented: boolean): Promise<void>;
    onDispose(): Promise<void>;
    transformToSimplePlayer(player: Player): IGameHistorySimplePlayer;
    swap(player: Player, pokemon: IPokemon, x: number, y: number): void;
    getPokemonByPosition(player: Player, x: number, y: number): Pokemon | undefined;
    spawnOnBench(player: Player, pkm: Pkm, anim?: "fishing" | "spawn"): void;
    checkEvolutionsAfterPokemonAcquired(playerId: string): boolean;
    checkEvolutionsAfterItemAcquired(playerId: string, pokemon: Pokemon): false | undefined;
    getNumberOfPlayersAlive(players: MapSchema<Player>): number;
    getTeamSize(board: MapSchema<Pokemon>): number;
    pickPokemonProposition(playerId: string, pkm: PkmProposition, bypassLackOfSpace?: boolean): void;
    pickItemProposition(playerId: string, item: Item): void;
    computeRoundDamage(opponentTeam: MapSchema<IPokemonEntity>, stageLevel: number): number;
    rankPlayers(): void;
}
